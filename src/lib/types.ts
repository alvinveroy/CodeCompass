import { z } from "zod";

// Schemas
export const SearchCodeSchema = z.object({ 
  query: z.string().min(1, "Query is required"),
  sessionId: z.string().optional()
});

export const GenerateSuggestionSchema = z.object({
  query: z.string().min(1, "Query is required").optional(),
  prompt: z.string().min(1, "Prompt is required").optional(),
  sessionId: z.string().optional()
}).transform((data) => ({
  query: data.query || data.prompt || "",
  sessionId: data.sessionId
})).refine(data => data.query.length > 0, {
  message: "Either query or prompt must be a non-empty string",
  path: ["query"],
});

export const GetRepositoryContextSchema = z.object({ 
  query: z.string().min(1, "Query is required"),
  sessionId: z.string().optional()
}).or(
  z.string().min(1, "Query is required").transform(query => ({ query }))
);

// FeedbackSchema removed

// Agent schema
export const AgentQuerySchema = z.object({
  query: z.string().min(1, "Query is required"),
  sessionId: z.string().optional()
  // maxSteps removed
});

// Zod schema for AgentStep
export const AgentStepSchema = z.object({
  tool: z.string(),
  input: z.unknown(),
  output: z.unknown(),
  reasoning: z.string(),
});

// Zod schema for AgentState
export const AgentStateSchema = z.object({
  sessionId: z.string(),
  query: z.string(),
  planText: z.string().optional(),
  steps: z.array(AgentStepSchema),
  context: z.array(z.unknown()),
  finalResponse: z.string().optional(),
  isComplete: z.boolean(),
});

// Types
export interface OllamaEmbeddingResponse { 
  embedding: number[] 
}

export interface OllamaGenerateResponse { 
  response: string 
}

export interface QdrantPoint { 
  id: string; 
  vector: number[]; 
  payload: { 
    filepath: string; 
    content: string; 
    last_modified: string 
  } 
}

export interface QdrantSearchResult { 
  id: string | number; 
  payload: { 
    content: string; 
    filepath: string; 
    last_modified: string 
  }; 
  score: number 
}

// Agent types
export interface AgentStep {
  tool: string;
  input: unknown;
  output: unknown;
  reasoning: string;
}

export interface AgentState {
  sessionId: string;
  query: string;
  planText?: string; // Stores the raw plan generated by the LLM
  steps: AgentStep[]; // Stores executed steps or a structured plan
  context: unknown[];
  finalResponse?: string;
  isComplete: boolean;
}

export interface AgentInitialQueryResponse {
  sessionId: string;
  status: "COMPLETED" | "ERROR"; // Status simplified: plan and summary are generated in one go or it errors.
  message: string;
  generatedPlanText?: string; // The raw plan text from the LLM
  agentState: AgentState; // The complete, updated agent state including the planText and finalResponse
}

// AgentStepExecutionResponse interface removed

export interface DetailedQdrantSearchResult {
  id: string | number;
  score: number;
  payload: {
    filepath: string;
    content: string;
    last_modified: string;
    // Add these optional properties:
    is_chunked?: boolean;
    chunk_index?: number;
    total_chunks?: number;
    [key: string]: unknown; // Allows for other potential payload fields
  };
  version?: number;
  vector?: number[] | Record<string, unknown> | number[][] | null;
  shard_key?: string;
  order_value?: number;
}

export interface ParsedToolCall {
  tool: string;
  parameters: Record<string, unknown>;
}
